Process
    Set Up Skeleton For Auth Service + Base Infra Setup (i.e. Skaffold & Ingress):
        - make auth directory and install base dependencies (with ts config file)
        - create dockerfile with instructions on building image

        - create auth deployment and auth service yaml file (deployment describes
        how to keep pods running, ClusterIP service enables internal network access)

        - create skaffold.yaml file to handle CI and sync updates from infra and src
        to cluster

        - create ingress-srv.yaml file in infra folder, which will create Ingress object 
        to handle routing web requests to running services (like auth or orders services)

        - write dummy test route in auth/src/index.ts to make sure that you have access to local
        cluster through Ingress nginx ('/api/users/current-user' route)
        - *manually change etc/hosts file so you can visit local version of ticketing.dev
        in your local browser (solely for development purposes!)

    Set Up Google Cloud Development Environment:
        - create new project in Google Cloud account and set up new Kubernetes cluster
        - install Google Cloud SDK on local machine, configure in ticketing directory, and
        connect local docker to Google Cloud cluster (now have options of desktop cluster
        or Google Cloud)
        - enable Google Cloud Build for CI in dashboard and update skaffold.yaml to replace local build with
        remote GCloud Build 
        - also replace local docker image ids with Google Cloud Id (image id: [HOSTNAME]/[PROJECT-ID]/[IMAGE])
        - install Ingress nginx in remote GCloud cluster and change etc/hosts file to reroute requests
        to ticketing.dev to GCloud load balancer IP address instead of local IP address

    Set Up Auth Route and Start Signup Error Handling:
        - setup skeletons for each route (signup, signin, signout, current user)
        - use express-validator library to validate input from signup form and parse request
        object for any errors appended onto it after middleware validation
        - problem to keep in mind is that there could many different sources of errors 
        (invalid input, info already in use, database connection down, etc) and we
        want uniform error object structure across application
        - create errorHandler middleware function that is used in auth's index.ts (anytime
        object with err, req, res, and next is received, errorHandler called)
        - create custom error subclasses for different potential errors types (helps us distinguish
        what error type is what and how to parse it into our uniform error we send back to client)
        - in errorHandler, parse custom error objects to form uniform error structure (i.e. array
        of errors each with properties _message and _field?)
        - still, we have the problem of 1) calling serializeErrors for each type of error 
        and 2) not having any formal structure that unifies the database and request validation
        errors; solution is to create abstract class CustomError so we can formally guarantee
        other error types conform to it and so we can call serialize error and get status code to
        send in error handler with guarantees
            - abstract CustomError class extends error but requires statusCode field and serializeErrors
            function
        - npm install express-async-errors to handle case of errors being thrown in async route handlers

    Database Creation and Modeling for Auth:
        - install mongoose and write auth-mongo-depl.yaml file to create running instance of mongo-db server for
        just auth service
        - connect auth/index.ts to mongoose instances auth database
        - create user schema and with it, the User model (db)
        - create interfaces to enforce strict types on parameters and return types for building documents 
        (schema instances)
            - interface userAttrs (parameters used to create new User object)
            - interface for mongoose.Model called UserModel so we can define custom build function that 
            uses userAttrs
            - interface for mongoose.Document called UserDoc so we can enforce structure of returned object when
            building a new User
        - update signup route to check for existing user, throw new BadRequestError if already in use, and create
        new user otherwise
        - add in password hashing class functions and Mongo pre-hook to hash password before storing

    Authentication Strategies:
        - in order to prevent total reliability on auth service for authentication, we will create shared library
        for all services that allows JWT authentication without using auth service
        - install jsonwebtoken and cookie session and have signup route stick jwt to req.session once user signs up
        - create jwt-secret for entire cluster with kubectl command and load with process.env
        - fix json response on successful auth to remove password (customize toJSON transform function)
        - start signin flow by adding basic error handling flow for bad inputs (make validateRequest middleware to
        share between auth and signin)
        - do error checking in signin route (email exists + password valid) and insert new jwt if checks pass
        - write current-user route, which checks if it has received jwt in body, then verifies it and sends back
        jwt payload field (which contains all user info)
        - write signout route, which sets req.session to null
        - extract current-user check for jwt existence and validity to current-user middleware, and stick payload
        on req.currentUser
        - add require auth middleware, which checks that req.currentUser exists (since current user middleware will
        set req.currentUser to null if no valid jwt)

    Testing Auth Service:
        - separate out express app and start script into app.ts and index.ts so we can still use app in test environment
        - install dev dependencies (Jest, Supertest), configure package.json scripts for Jest and testing setup,
        and write setup.ts testing setup script (creates dev JWT_KEY, instantiates mongo memory server and connection, clears out database
        before tests, and closes connection when test suites done)
        - write signup route tests and set cookie security to be false when in test env
        - write signin route tests
        - write current user route tests and add helper test file to set cookie on auth (getAuthCookie.ts)

    Starting Client React App:
        - install/setup react and next
        - set up client-depl.yaml and update skaffold.yaml to sync client deployment and update ingress-srv.yaml to route
        traffic to client as well
        - small fix by adding next.config.js to poll for sync updates (issues with next and skaffold)
        - import bootstrap css and make special _app.js page for next to be able to load up components and pageProps
        while still using bootstrap
        - make signup js component that makes axios request and add in form error display handling
        - create generalized useRequest hook component that exports a makeRequest function and set of errors that is
        set during makeRequest (takes in url, method, and body and can make any request)
        - add onSuccess callback to use next/router to redirect to index page on successful sign up
        - moving onto getting currentUser on index landing page, we have to make separate cases for whether
        or not we are on browser or server so we have separate request types, one to relative path and one to intercluster
        url (different base urls + need to carry over req.headers)
        - extracted out getInitialProps logic for dealing with server vs. browser requests into build-client file/function