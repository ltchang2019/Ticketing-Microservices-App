Process
    Set Up Skeleton For Auth Service + Base Infra Setup (i.e. Skaffold & Ingress):
        - make auth directory and install base dependencies (with ts config file)
        - create dockerfile with instructions on building image
        - create auth deployment and auth service yaml file (deployment describes
        how to keep pods running, ClusterIP service enables internal network access)
        - create skaffold.yaml file to handle CI and sync updates from infra and src
        to cluster
        - create ingress-srv.yaml file in infra folder, which will create Ingress object 
        to handle routing web requests to running services (like auth or orders services)
        - write dummy test route in auth/src/index.ts to make sure that you have access to local
        cluster through Ingress nginx ('/api/users/current-user' route)
        - *manually change etc/hosts file so you can visit local version of ticketing.dev
        in your local browser (solely for development purposes!)

    Set Up Google Cloud Development Environment:
        - create new project in Google Cloud account and set up new Kubernetes cluster
        - install Google Cloud SDK on local machine, configure in ticketing directory, and
        connect local docker to Google Cloud cluster (now have options of desktop cluster
        or Google Cloud)
        - enable Google Cloud Build for CI in dashboard and update skaffold.yaml to replace local build with
        remote GCloud Build 
        - also replace local docker image ids with Google Cloud Id (image id: [HOSTNAME]/[PROJECT-ID]/[IMAGE])
        - install Ingress nginx in remote GCloud cluster and change etc/hosts file to reroute requests
        to ticketing.dev to GCloud load balancer IP address instead of local IP address

    Set Up Auth Route and Start Signup Error Handling:
        - setup skeletons for each route (signup, signin, signout, current user)
        - use express-validator library to validate input from signup form and parse request
        object for any errors appended onto it after middleware validation
        - problem to keep in mind is that there could many different sources of errors 
        (invalid input, info already in use, database connection down, etc) and we
        want uniform error object structure across application
        - create errorHandler middleware function that is used in auth's index.ts (anytime
        object with err, req, res, and next is received, errorHandler called)
        - create custom error subclasses for different potential errors types (helps us distinguish
        what error type is what and how to parse it into our uniform error we send back to client)
        - in errorHandler, parse custom error objects to form uniform error structure (i.e. array
        of errors each with properties _message and _field?)
        - still, we have the problem of 1) calling serializeErrors for each type of error 
        and 2) not having any formal structure that unifies the database and request validation
        errors; solution is to create abstract class CustomError so we can formally guarantee
        other error types conform to it and so we can call serialize error and get status code to
        send in error handler with guarantees
            - abstract CustomError class extends error but requires statusCode field and serializeErrors
            function
        - npm install express-async-errors to handle case of errors being thrown in async route handlers

    Database Creation and Modeling for Auth:
        - install mongoose and write auth-mongo-depl.yaml file to create running instance of mongo-db server for
        just auth service
        - connect auth/index.ts to mongoose instances auth database
        - create user schema and with it, the User model (db)
        - create interfaces to enforce strict types on parameters and return types for building documents 
        (schema instances)
            - interface userAttrs (parameters used to create new User object)
            - interface for mongoose.Model called UserModel so we can define custom build function that 
            uses userAttrs
            - interface for mongoose.Document called UserDoc so we can enforce structure of returned object when
            building a new User
        - update signup route to check for existing user, throw new BadRequestError if already in use, and create
        new user otherwise
        - add in password hashing class functions and Mongo pre-hook to hash password before storing

    Authentication Strategies:
        - in order to prevent total reliability on auth service for authentication, we will create shared library
        for all services that allows JWT authentication without using auth service
        - install jsonwebtoken and cookie session and have signup route stick jwt to req.session once user signs up
        - create jwt-secret for entire cluster with kubectl command and load with process.env
        - fix json response on successful auth to remove password (customize toJSON transform function)
        - start signin flow by adding basic error handling flow for bad inputs (make validateRequest middleware to
        share between auth and signin)
        - do error checking in signin route (email exists + password valid) and insert new jwt if checks pass
        - write current-user route, which checks if it has received jwt in body, then verifies it and sends back
        jwt payload field (which contains all user info)
        - write signout route, which sets req.session to null
        - extract current-user check for jwt existence and validity to current-user middleware, and stick payload
        on req.currentUser
        - add require auth middleware, which checks that req.currentUser exists (since current user middleware will
        set req.currentUser to null if no valid jwt)

    Testing Auth Service:
        - separate out express app and start script into app.ts and index.ts so we can still use app in test environment
        - install dev dependencies (Jest, Supertest), configure package.json scripts for Jest and testing setup,
        and write setup.ts testing setup script (creates dev JWT_KEY, instantiates mongo memory server and connection, clears out database
        before tests, and closes connection when test suites done)
        - write signup route tests and set cookie security to be false when in test env
        - write signin route tests
        - write current user route tests and add helper test file to set cookie on auth (getAuthCookie.ts)

    Starting Client React App:
        - install/setup react and next
        - set up client-depl.yaml and update skaffold.yaml to sync client deployment and update ingress-srv.yaml to route
        traffic to client as well
        - small fix by adding next.config.js to poll for sync updates (issues with next and skaffold)
        - import bootstrap css and make special _app.js page for next to be able to load up components and pageProps
        while still using bootstrap
        - make signup js component that makes axios request and add in form error display handling
        - create generalized useRequest hook component that exports a makeRequest function and set of errors that is
        set during makeRequest (takes in url, method, and body and can make any request)
            - makeRequest makes axios call and inserts cookie and redirects onSuccess OR updates errors variable in signup page
            if error thrown 
        - add onSuccess callback to use next/router to redirect to index page on successful sign up
        - moving onto getting currentUser on index landing page, we have to make separate cases for whether
        or not we are on browser or server so we have separate request types, one to relative path and one to intercluster
        url (different base urls + need to carry over req.headers)
        - extract out getInitialProps logic for dealing with server vs. browser requests into resuable build-client file/function
        (returns generic axios object with correct base url)
        - create signin page (same as signup with different request)
        - moving on to app header creation, we change app's getInitialProps to get currentUser in app component but also manually call
        getInitialProps for the specific child page component (so we can get current user and whatever info specific page also needs)
        - now that we can pass currentUser status into header component in app, create frontend header component with conditional
        rendering and what not
        - create signout component that calls api and updates browser cookies

    Extracting Shared Auth Logic into NPM Package:
        - create npm organization and new common folder
        - rename package name to match npm organization and publish initial version
        - project setup to compile typescript files into javascript:
            - tsc --init and npm install typescript + del-cli
            - setup outDir to build in tscConfig and setup build and clean scripts
            - setup package.json to export index.js from build and use type declaration files
            - tell package.json to include files in build directory when publishing to npm
            - write npm publish script that will git add, commit, patch, build, and publish
        - cut error and middlewares folders from auth and paste into common/src folder (export all files from folders
        from index.ts file too to allow easy importing from @lt-ticketing)
        - fix all import statements in auth to use npm package

    Starting the Ticketing Service:
        - copy over necessary stuff from auth to speed up setup and npm install dependencies :)
        - create tickets-depl.yaml file for deploying tickets service and separate tickets-mongo-depl.yaml file
        - start writing failing tests for new POST /api/tickets route
        - create initial /api/tickets post route (new) that just sends simple status 200
        - add in requireAuth middleware to new route and add currentUser middleware to app
        - create mock cookie function that creates mock jwt (since we can't reach into auth srv for
        tickets testing)
        - add in new ticket title and price validation with express-validator and the validateRequest middleware
        - write ticket model for mongoose in with all custom interfaces, build fn, toJSON, etc
        - add functionality into new tickets route using new ticket model object
        - moving onto GET /api/tickets/:id route, write failing tests for this route
        - have GET ticket route return the ticket if found or throw if not
        - since the default 400 error in our common error handler will only be thrown for genuinely unexpected
        issues, add console.error to there so we can more easily debug in future
        - fix fake id format and create actual mongo id object for :id
        - write single test and implementation for index GET /api/tickets route
        - write failing tests for PUT /api/tickets/:id route
        - write necessary checks for ticket existence and user auth in PUT route
        - write check for user requesting update to own tickets