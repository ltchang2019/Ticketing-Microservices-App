Process
    Set Up Skeleton For Auth Service + Base Infra Setup (i.e. Skaffold & Ingress):
        - make auth directory and install base dependencies (with ts config file)
        - create dockerfile with instructions on building image

        - create auth deployment and auth service yaml file (deployment describes
        how to keep pods running, ClusterIP service enables internal network access)

        - create skaffold.yaml file to handle CI and sync updates from infra and src
        to cluster

        - create ingress-srv.yaml file in infra folder, which will create Ingress object 
        to handle routing web requests to running services (like auth or orders services)

        - write dummy test route in auth/src/index.ts to make sure that you have access to local
        cluster through Ingress nginx ('/api/users/current-user' route)
        - *manually change etc/hosts file so you can visit local version of ticketing.dev
        in your local browser (solely for development purposes!)

    Set Up Google Cloud Development Environment:
        - create new project in Google Cloud account and set up new Kubernetes cluster
        - install Google Cloud SDK on local machine, configure in ticketing directory, and
        connect local docker to Google Cloud cluster (now have options of desktop cluster
        or Google Cloud)
        - enable Google Cloud Build for CI in dashboard and update skaffold.yaml to replace local build with
        remote GCloud Build 
        - also replace local docker image ids with Google Cloud Id (image id: [HOSTNAME]/[PROJECT-ID]/[IMAGE])
        - install Ingress nginx in remote GCloud cluster and change etc/hosts file to reroute requests
        to ticketing.dev to GCloud load balancer IP address instead of local IP address

    Set Up Auth Route and Start Signup Error Handling:
        - setup skeletons for each route (signup, signin, signout, current user)
        - use express-validator library to validate input from signup form and parse request
        object for any errors appended onto it after middleware validation
        - problem to keep in mind is that there could many different sources of errors 
        (invalid input, info already in use, database connection down, etc) and we
        want uniform error object structure across application
        - create errorHandler middleware function that is used in auth's index.ts (anytime
        object with err, req, res, and next is received, errorHandler called)
        - create custom error subclasses for different potential errors types