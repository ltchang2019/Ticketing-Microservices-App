Process
    Set Up Skeleton For Auth Service + Base Infra Setup (i.e. Skaffold & Ingress):
        - make auth directory and install base dependencies (with ts config file)
        - create dockerfile with instructions on building image

        - create auth deployment and auth service yaml file (deployment describes
        how to keep pods running, ClusterIP service enables internal network access)

        - create skaffold.yaml file to handle CI and sync updates from infra and src
        to cluster

        - create ingress-srv.yaml file in infra folder, which will create Ingress object 
        to handle routing web requests to running services (like auth or orders services)

        - write dummy test route in auth/src/index.ts to make sure that you have access to local
        cluster through Ingress nginx ('/api/users/current-user' route)
        - *manually change etc/hosts file so you can visit local version of ticketing.dev
        in your local browser (solely for development purposes!)

    Set Up Google Cloud Development Environment:
        - create new project in Google Cloud account and set up new Kubernetes cluster
        - install Google Cloud SDK on local machine, configure in ticketing directory, and
        connect local docker to Google Cloud cluster (now have options of desktop cluster
        or Google Cloud)
        - enable Google Cloud Build for CI in dashboard and update skaffold.yaml to replace local build with
        remote GCloud Build 
        - also replace local docker image ids with Google Cloud Id (image id: [HOSTNAME]/[PROJECT-ID]/[IMAGE])
        - install Ingress nginx in remote GCloud cluster and change etc/hosts file to reroute requests
        to ticketing.dev to GCloud load balancer IP address instead of local IP address

    Set Up Auth Route and Start Signup Error Handling:
        - setup skeletons for each route (signup, signin, signout, current user)
        - use express-validator library to validate input from signup form and parse request
        object for any errors appended onto it after middleware validation
        - problem to keep in mind is that there could many different sources of errors 
        (invalid input, info already in use, database connection down, etc) and we
        want uniform error object structure across application
        - create errorHandler middleware function that is used in auth's index.ts (anytime
        object with err, req, res, and next is received, errorHandler called)
        - create custom error subclasses for different potential errors types (helps us distinguish
        what error type is what and how to parse it into our uniform error we send back to client)
        - in errorHandler, parse custom error objects to form uniform error structure (i.e. array
        of errors each with properties _message and _field?)
        - still, we have the problem of 1) calling serializeErrors for each type of error 
        and 2) not having any formal structure that unifies the database and request validation
        errors; solution is to create abstract class CustomError so we can formally guarantee
        other error types conform to it and so we can call serialize error and get status code to
        send in error handler with guarantees
            - abstract CustomError class extends error but requires statusCode field and serializeErrors
            function
        - npm install express-async-errors to handle case of errors being thrown in async route handlers

    Database Creation and Modeling for Auth:
        - install mongoose and write auth-mongo-depl.yaml file to create running instance of mongo-db server for
        just auth service
        - connect auth/index.ts to mongoose instances auth database
        - create user schema and with it, the User model (db)
        - create interfaces to enforce strict types on parameters and return types for building documents 
        (schema instances)
            - interface userAttrs (parameters used to create new User object)
            - interface for mongoose.Model called UserModel so we can define custom build function that 
            uses userAttrs
            - interface for mongoose.Document called UserDoc so we can enforce structure of returned object when
            building a new User
